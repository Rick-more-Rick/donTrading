<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MarketDepth Core â€” GrÃ¡ficos Financieros en Tiempo Real</title>
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     ESTILOS GLOBALES â€” Tema oscuro estilo terminal financiera
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Outfit:wght@300;400;600;700&display=swap');

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-panel: #151d2e;
            --border: #1e293b;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #475569;
            --accent-green: #22c55e;
            --accent-red: #ef4444;
            --accent-blue: #3b82f6;
            --accent-amber: #f59e0b;
            --accent-cyan: #06b6d4;
            --candle-up: #22c55e;
            --candle-down: #ef4444;
            --grid-color: rgba(30, 41, 59, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* â•â•â• HEADER / BARRA SUPERIOR â•â•â• */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            height: 48px;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            font-family: 'Outfit', sans-serif;
            font-weight: 700;
            font-size: 16px;
            color: var(--accent-cyan);
            letter-spacing: -0.5px;
        }

        .logo span {
            color: var(--text-muted);
            font-weight: 300;
        }

        .ticker-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-left: 16px;
            border-left: 1px solid var(--border);
        }

        .ticker-symbol {
            font-family: 'Outfit', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .ticker-price {
            font-size: 18px;
            font-weight: 700;
            transition: color 0.2s;
        }

        .ticker-change {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        .positive {
            color: var(--accent-green);
        }

        .negative {
            color: var(--accent-red);
        }

        .bg-positive {
            background: rgba(34, 197, 94, 0.15);
            color: var(--accent-green);
        }

        .bg-negative {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }

        .stat-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4);
            }

            50% {
                opacity: 0.7;
                box-shadow: 0 0 0 6px rgba(34, 197, 94, 0);
            }
        }

        /* â•â•â• TOOLBAR â•â•â• */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 4px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            gap: 4px;
            height: 36px;
        }

        .tool-btn {
            padding: 4px 12px;
            border: 1px solid transparent;
            border-radius: 4px;
            background: transparent;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .tool-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .tool-btn.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .tool-separator {
            width: 1px;
            height: 20px;
            background: var(--border);
            margin: 0 8px;
        }

        /* â•â•â• CONTENEDOR PRINCIPAL DEL GRÃFICO â•â•â• */
        .chart-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 48px - 36px - 32px);
            background: var(--bg-primary);
            overflow: hidden;
        }

        /* Todas las capas de canvas apiladas */
        .chart-container canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #heatmap-canvas {
            z-index: 1;
        }

        #candle-canvas {
            z-index: 2;
        }

        #overlay-canvas {
            z-index: 3;
        }

        #crosshair-canvas {
            z-index: 4;
            cursor: crosshair;
        }

        /* â•â•â• ESCALA DE PRECIOS (Derecha) â•â•â• */
        .price-scale {
            position: absolute;
            top: 0;
            right: 0;
            width: 80px;
            height: 100%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 0;
            overflow: hidden;
        }

        .price-label {
            font-size: 10px;
            color: var(--text-muted);
            text-align: right;
            padding-right: 8px;
            position: absolute;
            right: 0;
            transform: translateY(-50%);
        }

        .current-price-tag {
            position: absolute;
            right: 0;
            transform: translateY(-50%);
            padding: 3px 8px;
            font-size: 11px;
            font-weight: 700;
            border-radius: 2px 0 0 2px;
            z-index: 11;
            transition: all 0.15s;
        }

        /* â•â•â• ESCALA DE TIEMPO (Abajo) â•â•â• */
        .time-scale {
            position: absolute;
            bottom: 0;
            left: 0;
            width: calc(100% - 80px);
            height: 32px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            z-index: 10;
            display: flex;
            align-items: center;
        }

        .time-label {
            position: absolute;
            font-size: 10px;
            color: var(--text-muted);
            transform: translateX(-50%);
            bottom: 8px;
        }

        /* â•â•â• TOOLTIP / CROSSHAIR INFO â•â•â• */
        .crosshair-info {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 20;
            background: rgba(21, 29, 46, 0.9);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 11px;
            display: none;
            backdrop-filter: blur(8px);
        }

        .crosshair-info .row {
            display: flex;
            gap: 16px;
            margin: 2px 0;
        }

        .crosshair-info .label {
            color: var(--text-muted);
        }

        .crosshair-info .val {
            font-weight: 500;
        }

        /* â•â•â• PANEL DE MÃ‰TRICAS â•â•â• */
        .metrics-bar {
            display: flex;
            align-items: center;
            padding: 0 16px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            height: 32px;
            gap: 24px;
            font-size: 11px;
        }

        .metric {
            display: flex;
            gap: 6px;
        }

        .metric .label {
            color: var(--text-muted);
        }

        .metric .value {
            color: var(--text-secondary);
        }

        /* â•â•â• LEYENDA HEATMAP â•â•â• */
        .heatmap-legend {
            position: absolute;
            top: 8px;
            right: 92px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 9px;
            color: var(--text-muted);
            background: rgba(21, 29, 46, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }

        .legend-gradient {
            width: 80px;
            height: 8px;
            border-radius: 2px;
            background: linear-gradient(to right, #1e3a5f, #1e88e5, #fdd835, #ff6f00, #d50000);
        }

        /* â•â•â• CONTROLES DE ZOOM â•â•â• */
        .zoom-controls {
            position: absolute;
            bottom: 44px;
            right: 92px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-panel);
            color: var(--text-secondary);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .zoom-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--accent-blue);
        }
    </style>
</head>

<body>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     HEADER â€” InformaciÃ³n del instrumento
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="header">
        <div class="header-left">
            <div class="logo">MarketDepth<span>Core</span></div>
            <div class="ticker-info">
                <span class="ticker-symbol">AAPL</span>
                <span class="ticker-price" id="live-price">$189.45</span>
                <span class="ticker-change bg-positive" id="live-change">+1.23 (0.65%)</span>
            </div>
        </div>
        <div class="header-right">
            <div class="stat-box">
                <span class="stat-label">Vol</span>
                <span class="stat-value" id="stat-vol">0</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">High</span>
                <span class="stat-value" id="stat-high">$0</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">Low</span>
                <span class="stat-value" id="stat-low">$0</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">FPS</span>
                <span class="stat-value" id="stat-fps">60</span>
            </div>
            <div class="stat-box" style="border: none;">
                <span class="stat-label">Ticks/s</span>
                <span class="stat-value" id="stat-tps">0</span>
            </div>
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">LIVE</span>
            </div>
        </div>
    </div>

    <!-- â•â•â• TOOLBAR â•â•â• -->
    <div class="toolbar">
        <button class="tool-btn active" data-tf="1">1m</button>
        <button class="tool-btn" data-tf="5">5m</button>
        <button class="tool-btn" data-tf="15">15m</button>
        <button class="tool-btn" data-tf="60">1H</button>
        <div class="tool-separator"></div>
        <button class="tool-btn active" id="btn-candles">ğŸ•¯ Velas</button>
        <button class="tool-btn active" id="btn-heatmap">ğŸŒ¡ Heatmap</button>
        <button class="tool-btn active" id="btn-orderflow">ğŸ’§ Order Flow</button>
        <div class="tool-separator"></div>
        <button class="tool-btn" id="btn-contrast-up">Contraste +</button>
        <button class="tool-btn" id="btn-contrast-down">Contraste âˆ’</button>
        <div class="tool-separator"></div>
        <button class="tool-btn" id="btn-pause">â¸ Pausar</button>
        <button class="tool-btn" id="btn-reset">â†º Reset</button>
    </div>

    <!-- â•â•â• CONTENEDOR DEL GRÃFICO â•â•â• -->
    <div class="chart-container" id="chart-container">
        <!-- Capa 1: WebGL Heatmap (fondo) -->
        <canvas id="heatmap-canvas"></canvas>
        <!-- Capa 2: Canvas 2D Velas -->
        <canvas id="candle-canvas"></canvas>
        <!-- Capa 3: Canvas 2D Burbujas de Order Flow -->
        <canvas id="overlay-canvas"></canvas>
        <!-- Capa 4: Crosshair / InteracciÃ³n -->
        <canvas id="crosshair-canvas"></canvas>

        <!-- Escala de precios -->
        <div class="price-scale" id="price-scale"></div>

        <!-- Escala de tiempo -->
        <div class="time-scale" id="time-scale"></div>

        <!-- Leyenda del heatmap -->
        <div class="heatmap-legend">
            <span>Baja liquidez</span>
            <div class="legend-gradient"></div>
            <span>Alta liquidez</span>
        </div>

        <!-- Info del crosshair -->
        <div class="crosshair-info" id="crosshair-info">
            <div class="row"><span class="label">O</span> <span class="val" id="ci-open">â€”</span></div>
            <div class="row"><span class="label">H</span> <span class="val" id="ci-high">â€”</span></div>
            <div class="row"><span class="label">L</span> <span class="val" id="ci-low">â€”</span></div>
            <div class="row"><span class="label">C</span> <span class="val" id="ci-close">â€”</span></div>
            <div class="row"><span class="label">Vol</span> <span class="val" id="ci-vol">â€”</span></div>
        </div>

        <!-- Controles de zoom -->
        <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-out">âˆ’</button>
        </div>
    </div>

    <!-- â•â•â• BARRA DE MÃ‰TRICAS INFERIOR â•â•â• -->
    <div class="metrics-bar">
        <div class="metric"><span class="label">Bid:</span> <span class="value positive" id="m-bid">â€”</span></div>
        <div class="metric"><span class="label">Ask:</span> <span class="value negative" id="m-ask">â€”</span></div>
        <div class="metric"><span class="label">Spread:</span> <span class="value" id="m-spread">â€”</span></div>
        <div class="metric"><span class="label">Depth Bid:</span> <span class="value positive" id="m-dbid">â€”</span>
        </div>
        <div class="metric"><span class="label">Depth Ask:</span> <span class="value negative" id="m-dask">â€”</span>
        </div>
        <div class="metric"><span class="label">Ratio:</span> <span class="value" id="m-ratio">â€”</span></div>
        <div class="metric"><span class="label">Msgs:</span> <span class="value" id="m-msgs">0</span></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MarketDepth Core â€” Motor Completo de GrÃ¡ficos Financieros en Tiempo Real
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //
        // ARQUITECTURA DE 5 CAPAS:
        //   1. Simulador de Datos (reemplaza WebSocket real de Polygon/Massive)
        //   2. Ring Buffer (Buffer Circular para batching de datos)
        //   3. Motor de Velas (Canvas 2D â€” estilo TradingView)
        //   4. Motor Heatmap (Canvas 2D con algoritmo estilo Bookmap)
        //   5. Capa de Order Flow (Burbujas de volumen)
        //
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        (() => {
            'use strict';

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // CONSTANTES GLOBALES
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const PRICE_BASE = 189.00;           // Precio base de AAPL simulado
            const PRICE_PRECISION = 100;         // Multiplicador para evitar errores de punto flotante
            const CANDLE_WIDTH_RATIO = 0.7;      // Porcentaje del espacio de cada vela que ocupa el cuerpo
            const HEATMAP_LEVELS = 80;           // Niveles de precio en el heatmap
            const HEATMAP_HISTORY = 200;         // Columnas de historia del heatmap
            const TICK_INTERVAL = 50;            // Cada cuÃ¡ntos ms se genera un tick simulado
            const FLUSH_INTERVAL = 16;           // Cada cuÃ¡ntos ms se vacÃ­a el buffer (â‰ˆ60Hz)
            const MAX_VISIBLE_CANDLES = 80;      // CuÃ¡ntas velas se ven a la vez
            const PRICE_SCALE_WIDTH = 80;        // Ancho de la escala de precios en px
            const TIME_SCALE_HEIGHT = 32;        // Alto de la escala de tiempo en px

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // MÃ“DULO 1: RING BUFFER (Buffer Circular)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Â¿QuÃ© es? Imagina un tubo circular. Los datos entran por un lado
            // y cuando se llena, los datos nuevos sobrescriben los mÃ¡s viejos.
            // Esto evita que la memoria crezca infinitamente.
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            class RingBuffer {
                constructor(capacity) {
                    // Float64Array: un arreglo especial que solo guarda nÃºmeros decimales
                    // Es MUCHO mÃ¡s rÃ¡pido que un array normal de JavaScript
                    // Cada tick ocupa 4 posiciones: [precio, volumen, tiempo, lado]
                    this.data = new Float64Array(capacity * 4);
                    this.capacity = capacity;
                    this.head = 0;      // DÃ³nde escribimos el prÃ³ximo dato
                    this.count = 0;     // CuÃ¡ntos datos hay actualmente
                }

                // Agregar un tick al buffer
                push(price, volume, timestamp, side) {
                    const offset = this.head * 4;
                    this.data[offset] = price;
                    this.data[offset + 1] = volume;
                    this.data[offset + 2] = timestamp;
                    this.data[offset + 3] = side; // 1 = compra, -1 = venta
                    this.head = (this.head + 1) % this.capacity;
                    if (this.count < this.capacity) this.count++;
                }

                // Vaciar el buffer y devolver todos los datos acumulados
                flush() {
                    if (this.count === 0) return null;
                    // Copiamos solo los datos vÃ¡lidos
                    const result = new Float64Array(this.count * 4);
                    for (let i = 0; i < this.count; i++) {
                        const readIdx = ((this.head - this.count + i + this.capacity) % this.capacity) * 4;
                        result[i * 4] = this.data[readIdx];
                        result[i * 4 + 1] = this.data[readIdx + 1];
                        result[i * 4 + 2] = this.data[readIdx + 2];
                        result[i * 4 + 3] = this.data[readIdx + 3];
                    }
                    this.count = 0;
                    this.head = 0;
                    return result;
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // MÃ“DULO 2: SIMULADOR DE MERCADO
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // En producciÃ³n esto serÃ­a el WebSocket a Polygon.io/Massive.
            // Simula movimientos de precio realistas usando "random walk"
            // (caminata aleatoria) con volatilidad y tendencias.
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            class MarketSimulator {
                constructor() {
                    this.price = PRICE_BASE;
                    this.bid = this.price - 0.01;
                    this.ask = this.price + 0.01;
                    this.tickCount = 0;
                    this.totalVolume = 0;
                    this.sessionHigh = this.price;
                    this.sessionLow = this.price;

                    // Volatilidad: quÃ© tan "salvajemente" se mueve el precio
                    this.volatility = 0.0003;
                    // Tendencia: sesgo direccional (-1 a 1)
                    this.trend = 0;
                    this.trendDuration = 0;

                    // Libro de Ã³rdenes simulado (Order Book)
                    this.orderBook = new Map();
                    this._initOrderBook();
                }

                _initOrderBook() {
                    // Crear liquidez inicial: Ã³rdenes de compra y venta alrededor del precio
                    for (let i = -HEATMAP_LEVELS / 2; i < HEATMAP_LEVELS / 2; i++) {
                        const level = Math.round((this.price + i * 0.01) * PRICE_PRECISION);
                        // MÃ¡s liquidez cerca del precio actual, menos lejos
                        const distance = Math.abs(i);
                        const baseVol = Math.max(0, 500 - distance * 8 + Math.random() * 200);
                        if (baseVol > 0) this.orderBook.set(level, baseVol);
                    }
                }

                // Genera un "tick" â€” una actualizaciÃ³n de mercado
                generateTick() {
                    // Cambiar tendencia aleatoriamente
                    this.trendDuration--;
                    if (this.trendDuration <= 0) {
                        this.trend = (Math.random() - 0.5) * 2;
                        this.trendDuration = Math.floor(Math.random() * 200) + 50;
                    }

                    // Calcular movimiento de precio
                    // Box-Muller: genera nÃºmeros aleatorios con distribuciÃ³n normal (campana de Gauss)
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const normal = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    const move = normal * this.volatility * this.price + this.trend * 0.001;

                    this.price += move;
                    this.price = Math.round(this.price * 100) / 100;

                    // Actualizar bid/ask
                    const spread = 0.01 + Math.random() * 0.02;
                    this.bid = Math.round((this.price - spread / 2) * 100) / 100;
                    this.ask = Math.round((this.price + spread / 2) * 100) / 100;

                    // Generar volumen del trade
                    const volume = Math.floor(Math.random() * 500) + 10;
                    const side = Math.random() > 0.5 ? 1 : -1; // 1=compra, -1=venta

                    // Actualizar estadÃ­sticas
                    this.tickCount++;
                    this.totalVolume += volume;
                    if (this.price > this.sessionHigh) this.sessionHigh = this.price;
                    if (this.price < this.sessionLow) this.sessionLow = this.price;

                    // Actualizar libro de Ã³rdenes
                    this._updateOrderBook();

                    return { price: this.price, volume, time: Date.now(), side, bid: this.bid, ask: this.ask };
                }

                _updateOrderBook() {
                    // Simular cambios en el libro de Ã³rdenes
                    const priceInt = Math.round(this.price * PRICE_PRECISION);

                    for (let i = -HEATMAP_LEVELS / 2; i < HEATMAP_LEVELS / 2; i++) {
                        const level = priceInt + i;
                        const dist = Math.abs(i);
                        const current = this.orderBook.get(level) || 0;

                        // Variar volumen existente
                        let newVol = current + (Math.random() - 0.5) * 80;

                        // MÃ¡s liquidez cerca del precio
                        if (dist < 5) newVol += Math.random() * 100;

                        // Simular "icebergs" (Ã³rdenes grandes ocultas) ocasionalmente
                        if (Math.random() < 0.002) {
                            newVol += Math.random() * 3000;
                        }

                        newVol = Math.max(0, newVol);
                        if (newVol > 0) {
                            this.orderBook.set(level, newVol);
                        } else {
                            this.orderBook.delete(level);
                        }
                    }
                }

                getOrderBookSnapshot(minPrice, maxPrice) {
                    const snapshot = [];
                    const minInt = Math.round(minPrice * PRICE_PRECISION);
                    const maxInt = Math.round(maxPrice * PRICE_PRECISION);
                    this.orderBook.forEach((vol, priceInt) => {
                        if (priceInt >= minInt && priceInt <= maxInt) {
                            snapshot.push({ price: priceInt / PRICE_PRECISION, volume: vol });
                        }
                    });
                    return snapshot;
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // MÃ“DULO 3: MOTOR DE VELAS (Canvas 2D)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Dibuja el grÃ¡fico de velas japonesas.
            // Cada vela tiene: apertura, mÃ¡ximo, mÃ­nimo, cierre y volumen.
            // Verde = subiÃ³, Rojo = bajÃ³.
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            class CandleEngine {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.candles = [];
                    this.currentCandle = null;
                    this.candleInterval = 60000; // 1 minuto por vela
                    this.visibleStart = 0;
                    this.visibleCount = MAX_VISIBLE_CANDLES;

                    // Inicializar con velas histÃ³ricas simuladas
                    this._generateHistory();
                }

                _generateHistory() {
                    let price = PRICE_BASE - 2;
                    const now = Date.now();
                    for (let i = 0; i < 120; i++) {
                        const move = (Math.random() - 0.48) * 0.5;
                        const open = price;
                        const close = price + move;
                        const high = Math.max(open, close) + Math.random() * 0.3;
                        const low = Math.min(open, close) - Math.random() * 0.3;
                        const vol = Math.floor(Math.random() * 50000) + 5000;

                        this.candles.push({
                            time: now - (120 - i) * this.candleInterval,
                            open: Math.round(open * 100) / 100,
                            high: Math.round(high * 100) / 100,
                            low: Math.round(low * 100) / 100,
                            close: Math.round(close * 100) / 100,
                            volume: vol
                        });

                        price = close;
                    }
                    this.visibleStart = Math.max(0, this.candles.length - this.visibleCount);
                }

                // Procesar un nuevo tick y actualizar/crear vela
                processTick(tick) {
                    const candleTime = Math.floor(tick.time / this.candleInterval) * this.candleInterval;

                    if (!this.currentCandle || this.currentCandle.time !== candleTime) {
                        // Nueva vela
                        if (this.currentCandle) {
                            this.candles.push({ ...this.currentCandle });
                        }
                        this.currentCandle = {
                            time: candleTime,
                            open: tick.price,
                            high: tick.price,
                            low: tick.price,
                            close: tick.price,
                            volume: tick.volume
                        };
                        // Auto-scroll para mostrar la vela mÃ¡s reciente
                        this.visibleStart = Math.max(0, this.candles.length - this.visibleCount + 2);
                    } else {
                        // Actualizar vela actual
                        this.currentCandle.high = Math.max(this.currentCandle.high, tick.price);
                        this.currentCandle.low = Math.min(this.currentCandle.low, tick.price);
                        this.currentCandle.close = tick.price;
                        this.currentCandle.volume += tick.volume;
                    }
                }

                // Obtener el rango de precios visible
                getVisiblePriceRange() {
                    const visible = this._getVisibleCandles();
                    if (visible.length === 0) return { min: PRICE_BASE - 2, max: PRICE_BASE + 2 };

                    let min = Infinity, max = -Infinity;
                    visible.forEach(c => {
                        if (c.low < min) min = c.low;
                        if (c.high > max) max = c.high;
                    });

                    // AÃ±adir margen del 5% arriba y abajo
                    const padding = (max - min) * 0.05;
                    return { min: min - padding, max: max + padding };
                }

                _getVisibleCandles() {
                    const all = [...this.candles];
                    if (this.currentCandle) all.push(this.currentCandle);
                    return all.slice(this.visibleStart, this.visibleStart + this.visibleCount);
                }

                // Dibujar todas las velas
                render(chartWidth, chartHeight) {
                    const ctx = this.ctx;
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    const visible = this._getVisibleCandles();
                    if (visible.length === 0) return;

                    const priceRange = this.getVisiblePriceRange();
                    const candleSpace = chartWidth / this.visibleCount;
                    const candleWidth = candleSpace * CANDLE_WIDTH_RATIO;

                    // FunciÃ³n para convertir precio a coordenada Y
                    const priceToY = (price) => {
                        const normalized = (price - priceRange.min) / (priceRange.max - priceRange.min);
                        return chartHeight * (1 - normalized);
                    };

                    // Dibujar grid horizontal (lÃ­neas de precio)
                    ctx.strokeStyle = 'rgba(30, 41, 59, 0.4)';
                    ctx.lineWidth = 0.5;
                    const priceStep = this._niceStep(priceRange.max - priceRange.min, 8);
                    const startPrice = Math.ceil(priceRange.min / priceStep) * priceStep;
                    for (let p = startPrice; p < priceRange.max; p += priceStep) {
                        const y = priceToY(p);
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(chartWidth, y);
                        ctx.stroke();
                    }

                    // Dibujar cada vela
                    visible.forEach((candle, i) => {
                        const x = i * candleSpace + candleSpace / 2;
                        const isUp = candle.close >= candle.open;

                        const bodyTop = priceToY(Math.max(candle.open, candle.close));
                        const bodyBottom = priceToY(Math.min(candle.open, candle.close));
                        const bodyHeight = Math.max(1, bodyBottom - bodyTop);

                        const wickTop = priceToY(candle.high);
                        const wickBottom = priceToY(candle.low);

                        // Colores
                        const color = isUp ? '#22c55e' : '#ef4444';
                        const bodyColor = isUp ? 'rgba(34, 197, 94, 0.85)' : 'rgba(239, 68, 68, 0.85)';

                        // Mecha (la lÃ­nea vertical fina)
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, wickTop);
                        ctx.lineTo(x, wickBottom);
                        ctx.stroke();

                        // Cuerpo (el rectÃ¡ngulo)
                        ctx.fillStyle = bodyColor;
                        ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);

                        // Borde del cuerpo
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                    });

                    // LÃ­nea del precio actual (lÃ­nea punteada horizontal)
                    if (this.currentCandle) {
                        const y = priceToY(this.currentCandle.close);
                        ctx.setLineDash([4, 4]);
                        ctx.strokeStyle = this.currentCandle.close >= this.currentCandle.open
                            ? 'rgba(34, 197, 94, 0.6)' : 'rgba(239, 68, 68, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(chartWidth, y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // Calcular un "paso bonito" para las lÃ­neas de grid
                _niceStep(range, targetTicks) {
                    const rough = range / targetTicks;
                    const pow = Math.pow(10, Math.floor(Math.log10(rough)));
                    const frac = rough / pow;
                    let nice;
                    if (frac <= 1.5) nice = 1;
                    else if (frac <= 3) nice = 2;
                    else if (frac <= 7) nice = 5;
                    else nice = 10;
                    return nice * pow;
                }

                zoom(factor) {
                    this.visibleCount = Math.max(20, Math.min(200, Math.round(this.visibleCount * factor)));
                    this.visibleStart = Math.max(0, this.candles.length - this.visibleCount + 2);
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // MÃ“DULO 4: MOTOR HEATMAP (Canvas 2D con gradientes)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Dibuja el "mapa de calor" del libro de Ã³rdenes.
            // Cada celda muestra cuÃ¡nta liquidez hay en ese nivel de precio.
            // Colores frÃ­os = poca liquidez, calientes = mucha liquidez.
            // 
            // NOTA: En producciÃ³n usarÃ­as WebGL con shaders GLSL
            // para mÃ¡ximo rendimiento. AquÃ­ usamos Canvas 2D con
            // el mismo algoritmo para que funcione sin dependencias.
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            class HeatmapEngine {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');

                    // Matriz de datos: cada celda tiene un valor de liquidez
                    // Filas = niveles de precio, Columnas = momentos en el tiempo
                    this.textureData = new Float32Array(HEATMAP_LEVELS * HEATMAP_HISTORY);
                    this.currentColumn = 0;

                    // Contraste adaptativo (el "algoritmo secreto" de Bookmap)
                    this.contrast = 5.0;
                    this.p95Volume = 500; // Percentil 95 de referencia

                    // Paleta de colores (azul frÃ­o â†’ amarillo â†’ rojo caliente)
                    this.colorStops = [
                        { pos: 0.0, r: 10, g: 20, b: 50 },  // Casi invisible (fondo)
                        { pos: 0.15, r: 20, g: 50, b: 100 },  // Azul muy oscuro
                        { pos: 0.3, r: 30, g: 100, b: 180 },  // Azul medio
                        { pos: 0.5, r: 30, g: 136, b: 229 },  // Azul brillante
                        { pos: 0.65, r: 253, g: 216, b: 53 },  // Amarillo
                        { pos: 0.8, r: 255, g: 111, b: 0 },  // Naranja
                        { pos: 0.95, r: 213, g: 0, b: 0 },  // Rojo
                        { pos: 1.0, r: 255, g: 255, b: 255 },  // Blanco (mÃ¡ximo)
                    ];
                }

                // Recibir un snapshot del libro de Ã³rdenes y escribir una columna
                pushSnapshot(orderBookData, minPrice, maxPrice) {
                    const col = this.currentColumn % HEATMAP_HISTORY;
                    const priceStep = (maxPrice - minPrice) / HEATMAP_LEVELS;

                    // Limpiar la columna
                    for (let row = 0; row < HEATMAP_LEVELS; row++) {
                        this.textureData[row * HEATMAP_HISTORY + col] = 0;
                    }

                    // Llenar con datos del libro de Ã³rdenes
                    orderBookData.forEach(entry => {
                        const row = Math.floor((entry.price - minPrice) / priceStep);
                        if (row >= 0 && row < HEATMAP_LEVELS) {
                            const idx = row * HEATMAP_HISTORY + col;
                            // Max pooling: si varios precios caen en el mismo pÃ­xel, quedarse con el mayor
                            this.textureData[idx] = Math.max(this.textureData[idx], entry.volume);
                        }
                    });

                    this.currentColumn++;
                    this._updateP95();
                }

                // Calcular Percentil 95 â€” el "algoritmo de contraste adaptativo"
                // Esto evita que una sola orden gigante haga invisible todo lo demÃ¡s
                _updateP95() {
                    const values = [];
                    for (let i = 0; i < this.textureData.length; i++) {
                        if (this.textureData[i] > 0) values.push(this.textureData[i]);
                    }
                    if (values.length > 0) {
                        values.sort((a, b) => a - b);
                        this.p95Volume = values[Math.floor(values.length * 0.95)] || 500;
                    }
                }

                // Convertir un valor de liquidez a un color usando la paleta
                _valueToColor(value) {
                    // NormalizaciÃ³n logarÃ­tmica: log(1 + value * contrast)
                    // Esto comprime el rango para que las diferencias pequeÃ±as se vean
                    const normalized = Math.log(1 + value * this.contrast) / Math.log(1 + this.p95Volume * this.contrast);
                    const t = Math.min(1, Math.max(0, normalized));

                    // Interpolar en la paleta de colores
                    for (let i = 0; i < this.colorStops.length - 1; i++) {
                        const c1 = this.colorStops[i];
                        const c2 = this.colorStops[i + 1];
                        if (t >= c1.pos && t <= c2.pos) {
                            const local = (t - c1.pos) / (c2.pos - c1.pos);
                            return {
                                r: Math.round(c1.r + (c2.r - c1.r) * local),
                                g: Math.round(c1.g + (c2.g - c1.g) * local),
                                b: Math.round(c1.b + (c2.b - c1.b) * local),
                                a: t < 0.05 ? t / 0.05 : 1 // Transparente si el valor es muy bajo
                            };
                        }
                    }
                    return { r: 255, g: 255, b: 255, a: 1 };
                }

                render(chartWidth, chartHeight) {
                    const ctx = this.ctx;
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    const colWidth = chartWidth / HEATMAP_HISTORY;
                    const rowHeight = chartHeight / HEATMAP_LEVELS;

                    const startCol = Math.max(0, this.currentColumn - HEATMAP_HISTORY);

                    for (let row = 0; row < HEATMAP_LEVELS; row++) {
                        for (let histCol = 0; histCol < Math.min(this.currentColumn, HEATMAP_HISTORY); histCol++) {
                            const dataCol = histCol % HEATMAP_HISTORY;
                            const value = this.textureData[row * HEATMAP_HISTORY + dataCol];

                            if (value > 0) {
                                const color = this._valueToColor(value);
                                ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a * 0.7})`;
                                const x = histCol * colWidth;
                                const y = chartHeight - (row + 1) * rowHeight;
                                ctx.fillRect(x, y, colWidth + 1, rowHeight + 1);
                            }
                        }
                    }
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // MÃ“DULO 5: CAPA DE ORDER FLOW (Burbujas)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Dibuja cÃ­rculos (burbujas) donde ocurren las transacciones.
            // TamaÃ±o = volumen de la transacciÃ³n
            // Verde = compra agresiva, Rojo = venta agresiva
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            class OrderFlowOverlay {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.bubbles = []; // Lista de burbujas activas
                    this.maxBubbles = 150;
                }

                addTrade(price, volume, side, x, y) {
                    // Radio = raÃ­z cuadrada del volumen * escala
                    // Â¿Por quÃ© raÃ­z cuadrada? Porque el ÃREA del cÃ­rculo es Ï€rÂ²
                    // Si usÃ¡ramos el volumen directamente como radio, un trade de 400
                    // se verÃ­a 400x mÃ¡s grande, pero en realidad es solo 20x mÃ¡s en volumen
                    const radius = Math.sqrt(volume) * 0.3;

                    this.bubbles.push({
                        x, y, price, volume, side,
                        radius: Math.max(3, Math.min(radius, 40)),
                        opacity: 0.9,
                        age: 0
                    });

                    // Limitar cantidad de burbujas para no saturar la memoria
                    if (this.bubbles.length > this.maxBubbles) {
                        this.bubbles.shift();
                    }
                }

                render() {
                    const ctx = this.ctx;
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    this.bubbles.forEach((b, i) => {
                        b.age++;
                        b.opacity = Math.max(0, 0.9 - b.age * 0.003);

                        if (b.opacity <= 0) return;

                        const color = b.side === 1
                            ? `rgba(34, 197, 94, ${b.opacity})`   // Verde = compra
                            : `rgba(239, 68, 68, ${b.opacity})`;    // Rojo = venta

                        const glowColor = b.side === 1
                            ? `rgba(34, 197, 94, ${b.opacity * 0.3})`
                            : `rgba(239, 68, 68, ${b.opacity * 0.3})`;

                        // Glow (resplandor)
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.radius * 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = glowColor;
                        ctx.fill();

                        // Burbuja principal
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.fill();

                        // Borde
                        ctx.strokeStyle = b.side === 1
                            ? `rgba(34, 197, 94, ${b.opacity * 0.5})`
                            : `rgba(239, 68, 68, ${b.opacity * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Texto de volumen para burbujas grandes
                        if (b.radius > 12) {
                            ctx.fillStyle = `rgba(255,255,255,${b.opacity * 0.9})`;
                            ctx.font = `${Math.max(8, b.radius * 0.5)}px JetBrains Mono`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(b.volume >= 1000 ? (b.volume / 1000).toFixed(1) + 'K' : b.volume, b.x, b.y);
                        }
                    });

                    // Limpiar burbujas ya invisibles
                    this.bubbles = this.bubbles.filter(b => b.opacity > 0);
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // MÃ“DULO 6: CROSSHAIR (Cruz de referencia)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            class Crosshair {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.mouseX = -1;
                    this.mouseY = -1;
                    this.visible = false;
                }

                render(chartWidth, chartHeight) {
                    const ctx = this.ctx;
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    if (!this.visible || this.mouseX < 0) return;

                    ctx.setLineDash([3, 3]);
                    ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
                    ctx.lineWidth = 0.5;

                    // LÃ­nea horizontal
                    ctx.beginPath();
                    ctx.moveTo(0, this.mouseY);
                    ctx.lineTo(chartWidth, this.mouseY);
                    ctx.stroke();

                    // LÃ­nea vertical
                    ctx.beginPath();
                    ctx.moveTo(this.mouseX, 0);
                    ctx.lineTo(this.mouseX, chartHeight);
                    ctx.stroke();

                    ctx.setLineDash([]);
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // MÃ“DULO 7: CONTROLADOR PRINCIPAL (Orquestador)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Este es el "director de orquesta" que coordina todos
            // los mÃ³dulos anteriores.
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            class MarketDepthCore {
                constructor() {
                    // Obtener referencias a los canvas del HTML
                    this.container = document.getElementById('chart-container');
                    this.heatmapCanvas = document.getElementById('heatmap-canvas');
                    this.candleCanvas = document.getElementById('candle-canvas');
                    this.overlayCanvas = document.getElementById('overlay-canvas');
                    this.crosshairCanvas = document.getElementById('crosshair-canvas');

                    // Crear instancias de cada mÃ³dulo
                    this.simulator = new MarketSimulator();
                    this.ringBuffer = new RingBuffer(10000);
                    this.candleEngine = new CandleEngine(this.candleCanvas);
                    this.heatmapEngine = new HeatmapEngine(this.heatmapCanvas);
                    this.orderFlow = new OrderFlowOverlay(this.overlayCanvas);
                    this.crosshair = new Crosshair(this.crosshairCanvas);

                    // Estado
                    this.isPaused = false;
                    this.showCandles = true;
                    this.showHeatmap = true;
                    this.showOrderFlow = true;

                    // MÃ©tricas de rendimiento
                    this.frameCount = 0;
                    this.lastFpsTime = Date.now();
                    this.fps = 60;
                    this.ticksPerSecond = 0;
                    this.tickCountWindow = 0;
                    this.lastTpsTime = Date.now();
                    this.totalMessages = 0;

                    // Heatmap push interval
                    this.heatmapTimer = 0;

                    this._resize();
                    this._bindEvents();
                    this._startDataFeed();
                    this._startRenderLoop();
                }

                _resize() {
                    const w = this.container.clientWidth - PRICE_SCALE_WIDTH;
                    const h = this.container.clientHeight - TIME_SCALE_HEIGHT;
                    const dpr = window.devicePixelRatio || 1;

                    [this.heatmapCanvas, this.candleCanvas, this.overlayCanvas, this.crosshairCanvas].forEach(c => {
                        c.width = w * dpr;
                        c.height = h * dpr;
                        c.style.width = w + 'px';
                        c.style.height = h + 'px';
                        c.getContext('2d').scale(dpr, dpr);
                    });

                    this.chartWidth = w;
                    this.chartHeight = h;
                }

                _bindEvents() {
                    window.addEventListener('resize', () => this._resize());

                    // Crosshair
                    this.crosshairCanvas.addEventListener('mousemove', (e) => {
                        const rect = this.crosshairCanvas.getBoundingClientRect();
                        this.crosshair.mouseX = e.clientX - rect.left;
                        this.crosshair.mouseY = e.clientY - rect.top;
                        this.crosshair.visible = true;
                        this._updateCrosshairInfo();
                    });

                    this.crosshairCanvas.addEventListener('mouseleave', () => {
                        this.crosshair.visible = false;
                        document.getElementById('crosshair-info').style.display = 'none';
                    });

                    // Zoom con rueda del ratÃ³n
                    this.crosshairCanvas.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        const factor = e.deltaY > 0 ? 1.1 : 0.9;
                        this.candleEngine.zoom(factor);
                    });

                    // Botones de zoom
                    document.getElementById('zoom-in').addEventListener('click', () => this.candleEngine.zoom(0.8));
                    document.getElementById('zoom-out').addEventListener('click', () => this.candleEngine.zoom(1.2));

                    // Toggle de capas
                    document.getElementById('btn-candles').addEventListener('click', (e) => {
                        this.showCandles = !this.showCandles;
                        e.target.classList.toggle('active');
                    });
                    document.getElementById('btn-heatmap').addEventListener('click', (e) => {
                        this.showHeatmap = !this.showHeatmap;
                        e.target.classList.toggle('active');
                    });
                    document.getElementById('btn-orderflow').addEventListener('click', (e) => {
                        this.showOrderFlow = !this.showOrderFlow;
                        e.target.classList.toggle('active');
                    });

                    // Contraste del heatmap
                    document.getElementById('btn-contrast-up').addEventListener('click', () => {
                        this.heatmapEngine.contrast = Math.min(20, this.heatmapEngine.contrast + 1);
                    });
                    document.getElementById('btn-contrast-down').addEventListener('click', () => {
                        this.heatmapEngine.contrast = Math.max(1, this.heatmapEngine.contrast - 1);
                    });

                    // Pausar / Reset
                    document.getElementById('btn-pause').addEventListener('click', (e) => {
                        this.isPaused = !this.isPaused;
                        e.target.textContent = this.isPaused ? 'â–¶ Reanudar' : 'â¸ Pausar';
                        document.getElementById('status-dot').style.background = this.isPaused ? '#f59e0b' : '#22c55e';
                        document.getElementById('status-text').textContent = this.isPaused ? 'PAUSED' : 'LIVE';
                    });

                    document.getElementById('btn-reset').addEventListener('click', () => location.reload());

                    // Timeframes
                    document.querySelectorAll('[data-tf]').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            document.querySelectorAll('[data-tf]').forEach(b => b.classList.remove('active'));
                            e.target.classList.add('active');
                            const minutes = parseInt(e.target.dataset.tf);
                            this.candleEngine.candleInterval = minutes * 60000;
                        });
                    });
                }

                _updateCrosshairInfo() {
                    const priceRange = this.candleEngine.getVisiblePriceRange();
                    const y = this.crosshair.mouseY;
                    const normalized = 1 - (y / this.chartHeight);
                    const price = priceRange.min + normalized * (priceRange.max - priceRange.min);

                    // Encontrar la vela bajo el cursor
                    const visible = this.candleEngine._getVisibleCandles();
                    const candleSpace = this.chartWidth / this.candleEngine.visibleCount;
                    const idx = Math.floor(this.crosshair.mouseX / candleSpace);

                    if (idx >= 0 && idx < visible.length) {
                        const candle = visible[idx];
                        const info = document.getElementById('crosshair-info');
                        info.style.display = 'block';
                        document.getElementById('ci-open').textContent = '$' + candle.open.toFixed(2);
                        document.getElementById('ci-high').textContent = '$' + candle.high.toFixed(2);
                        document.getElementById('ci-low').textContent = '$' + candle.low.toFixed(2);
                        document.getElementById('ci-close').textContent = '$' + candle.close.toFixed(2);
                        document.getElementById('ci-vol').textContent = candle.volume.toLocaleString();

                        const isUp = candle.close >= candle.open;
                        ['ci-open', 'ci-high', 'ci-low', 'ci-close'].forEach(id => {
                            document.getElementById(id).className = 'val ' + (isUp ? 'positive' : 'negative');
                        });
                    }
                }

                // Iniciar el flujo de datos simulado (reemplaza WebSocket)
                _startDataFeed() {
                    setInterval(() => {
                        if (this.isPaused) return;

                        // Generar entre 1 y 5 ticks por intervalo (simula rÃ¡fagas)
                        const burstSize = Math.floor(Math.random() * 5) + 1;
                        for (let i = 0; i < burstSize; i++) {
                            const tick = this.simulator.generateTick();
                            this.ringBuffer.push(tick.price, tick.volume, tick.time, tick.side);
                            this.tickCountWindow++;
                            this.totalMessages++;
                        }
                    }, TICK_INTERVAL);

                    // Vaciar el buffer a 60Hz (batching)
                    setInterval(() => {
                        if (this.isPaused) return;
                        const batch = this.ringBuffer.flush();
                        if (!batch) return;

                        // Procesar cada tick del lote
                        for (let i = 0; i < batch.length; i += 4) {
                            const tick = {
                                price: batch[i],
                                volume: batch[i + 1],
                                time: batch[i + 2],
                                side: batch[i + 3]
                            };
                            this.candleEngine.processTick(tick);

                            // AÃ±adir burbuja de order flow con probabilidad
                            if (tick.volume > 100 && Math.random() < 0.3) {
                                const priceRange = this.candleEngine.getVisiblePriceRange();
                                const normalized = (tick.price - priceRange.min) / (priceRange.max - priceRange.min);
                                const y = this.chartHeight * (1 - normalized);
                                const x = this.chartWidth * (0.85 + Math.random() * 0.12);
                                this.orderFlow.addTrade(tick.price, tick.volume, tick.side, x, y);
                            }
                        }

                        // Actualizar heatmap cada ciertos frames
                        this.heatmapTimer++;
                        if (this.heatmapTimer % 3 === 0) {
                            const priceRange = this.candleEngine.getVisiblePriceRange();
                            const snapshot = this.simulator.getOrderBookSnapshot(priceRange.min, priceRange.max);
                            this.heatmapEngine.pushSnapshot(snapshot, priceRange.min, priceRange.max);
                        }
                    }, FLUSH_INTERVAL);
                }

                // Bucle de renderizado sincronizado con el monitor
                _startRenderLoop() {
                    const loop = () => {
                        this.frameCount++;

                        // Calcular FPS
                        const now = Date.now();
                        if (now - this.lastFpsTime >= 1000) {
                            this.fps = this.frameCount;
                            this.frameCount = 0;
                            this.lastFpsTime = now;
                            document.getElementById('stat-fps').textContent = this.fps;
                        }

                        // Calcular Ticks/s
                        if (now - this.lastTpsTime >= 1000) {
                            this.ticksPerSecond = this.tickCountWindow;
                            this.tickCountWindow = 0;
                            this.lastTpsTime = now;
                            document.getElementById('stat-tps').textContent = this.ticksPerSecond;
                        }

                        // Renderizar cada capa
                        if (this.showHeatmap) this.heatmapEngine.render(this.chartWidth, this.chartHeight);
                        if (this.showCandles) this.candleEngine.render(this.chartWidth, this.chartHeight);
                        if (this.showOrderFlow) this.orderFlow.render();
                        this.crosshair.render(this.chartWidth, this.chartHeight);

                        // Actualizar UI
                        this._updateUI();
                        this._updatePriceScale();
                        this._updateTimeScale();

                        requestAnimationFrame(loop);
                    };
                    requestAnimationFrame(loop);
                }

                _updateUI() {
                    const sim = this.simulator;
                    const price = sim.price;
                    const change = price - PRICE_BASE;
                    const changePct = (change / PRICE_BASE * 100);
                    const isUp = change >= 0;

                    document.getElementById('live-price').textContent = '$' + price.toFixed(2);
                    document.getElementById('live-price').className = 'ticker-price ' + (isUp ? 'positive' : 'negative');
                    document.getElementById('live-change').textContent =
                        `${isUp ? '+' : ''}${change.toFixed(2)} (${changePct.toFixed(2)}%)`;
                    document.getElementById('live-change').className =
                        'ticker-change ' + (isUp ? 'bg-positive' : 'bg-negative');

                    document.getElementById('stat-vol').textContent = (sim.totalVolume / 1000).toFixed(0) + 'K';
                    document.getElementById('stat-high').textContent = '$' + sim.sessionHigh.toFixed(2);
                    document.getElementById('stat-low').textContent = '$' + sim.sessionLow.toFixed(2);

                    // MÃ©tricas inferiores
                    document.getElementById('m-bid').textContent = '$' + sim.bid.toFixed(2);
                    document.getElementById('m-ask').textContent = '$' + sim.ask.toFixed(2);
                    document.getElementById('m-spread').textContent = (sim.ask - sim.bid).toFixed(3);
                    document.getElementById('m-msgs').textContent = this.totalMessages.toLocaleString();

                    // Depth totals
                    let bidTotal = 0, askTotal = 0;
                    const priceInt = Math.round(sim.price * PRICE_PRECISION);
                    sim.orderBook.forEach((vol, p) => {
                        if (p < priceInt) bidTotal += vol;
                        else askTotal += vol;
                    });
                    document.getElementById('m-dbid').textContent = (bidTotal / 1000).toFixed(1) + 'K';
                    document.getElementById('m-dask').textContent = (askTotal / 1000).toFixed(1) + 'K';
                    const ratio = bidTotal / (askTotal || 1);
                    const ratioEl = document.getElementById('m-ratio');
                    ratioEl.textContent = ratio.toFixed(2);
                    ratioEl.className = 'value ' + (ratio > 1 ? 'positive' : 'negative');
                }

                _updatePriceScale() {
                    const scale = document.getElementById('price-scale');
                    scale.innerHTML = '';

                    const priceRange = this.candleEngine.getVisiblePriceRange();
                    const step = this.candleEngine._niceStep(priceRange.max - priceRange.min, 8);
                    const startPrice = Math.ceil(priceRange.min / step) * step;

                    for (let p = startPrice; p < priceRange.max; p += step) {
                        const normalized = (p - priceRange.min) / (priceRange.max - priceRange.min);
                        const y = this.chartHeight * (1 - normalized);
                        const label = document.createElement('div');
                        label.className = 'price-label';
                        label.style.top = y + 'px';
                        label.textContent = '$' + p.toFixed(2);
                        scale.appendChild(label);
                    }

                    // Tag del precio actual
                    const currentPrice = this.simulator.price;
                    const norm = (currentPrice - priceRange.min) / (priceRange.max - priceRange.min);
                    const cy = this.chartHeight * (1 - norm);
                    if (cy > 0 && cy < this.chartHeight) {
                        const tag = document.createElement('div');
                        tag.className = 'current-price-tag';
                        tag.style.top = cy + 'px';
                        const isUp = currentPrice >= PRICE_BASE;
                        tag.style.background = isUp ? '#22c55e' : '#ef4444';
                        tag.style.color = '#fff';
                        tag.textContent = '$' + currentPrice.toFixed(2);
                        scale.appendChild(tag);
                    }
                }

                _updateTimeScale() {
                    const scale = document.getElementById('time-scale');
                    scale.innerHTML = '';

                    const visible = this.candleEngine._getVisibleCandles();
                    const candleSpace = this.chartWidth / this.candleEngine.visibleCount;

                    visible.forEach((candle, i) => {
                        if (i % Math.max(1, Math.floor(this.candleEngine.visibleCount / 8)) === 0) {
                            const x = i * candleSpace + candleSpace / 2;
                            const date = new Date(candle.time);
                            const label = document.createElement('div');
                            label.className = 'time-label';
                            label.style.left = x + 'px';
                            label.textContent = date.getHours().toString().padStart(2, '0') + ':' +
                                date.getMinutes().toString().padStart(2, '0');
                            scale.appendChild(label);
                        }
                    });
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // ARRANQUE
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            window.addEventListener('DOMContentLoaded', () => {
                window.app = new MarketDepthCore();
            });

        })();
    </script>
</body>

</html>